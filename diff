diff --git a/src/add.s b/src/add.s
index 09a9c7a..f375f49 100644
--- a/src/add.s
+++ b/src/add.s
@@ -1,20 +1,21 @@
-.extern puts
-.extern printf
-
 SYS_WRITE = 1
 SYS_EXIT = 60
+
+STDIN  = 0
 STDOUT = 1
+STDERR = 2
 
+# size of single chunk of bignum on bytes
+CHUNK_SIZE = 8
 TEST_A_HIGH = 0x0000000200000000
 TEST_A_LOW  = 0x8000000000000000
 TEST_B_HIGH = 0x0003800000000000
 TEST_B_LOW  = 0x8000000000000000
 
-.section .data
-HELLO_STR: .asciz "Hello world\n"
-HELLO_STR_LEN = . - HELLO_STR
-FORMAT: .asciz "0x%016lx 0x%016lx\n"
+.global add_bignum
+.global add_bignum_fast
 
+.section .text
 TEST_BIGNUM_A:
 	.8byte TEST_A_LOW
 	.8byte TEST_A_HIGH
@@ -22,18 +23,7 @@ TEST_BIGNUM_B:
 	.8byte TEST_B_LOW
 	.8byte TEST_B_HIGH
 
-.section .text
-.global asm_main
-asm_main:
-	leaq HELLO_STR(%rip), %rdi
-	call puts 
-
-	movq $TEST_A_HIGH, %rax
-	movq $TEST_A_LOW, %rbx
-	movq $TEST_B_HIGH, %rcx
-	movq $TEST_B_LOW, %rdx
-	call add128
-
+add_test:
 	leaq TEST_BIGNUM_A(%rip), %rsi
 	leaq TEST_BIGNUM_B(%rip), %rdi
 	movq $2, %rcx
@@ -43,52 +33,50 @@ asm_main:
 	#movq $0, %rdi # error code
 	xor %rdi, %rdi
 	syscall
+  int3
 
-loop:
-	jmp loop
-
-# arguments passed in rax:rbx and rcx:rdx
-# return value in rax:rbx
-add128:
-	addq %rdx, %rbx
-	adcq %rcx, %rax
-	ret
-
-# Adds two bignums, stores results in second one
-# rdi = i64 *bignum1
-# rsi = i64 *bignum2
-# rdx = i64 bignum_size in 64 bit chunks
-# return value under rax
-# discards: r8, r9, rbx
-.global add_bignum
+# Adds two bignums and puts result in first of them
+# bignums can differ in size
+# the bigger one will contain result
+# void add_bignum(struct bignum b1, struct bignum b2)
 add_bignum:
+  mov %rcx, %r8
+  cmp %rcx, %rsi
+  cmovs %rsi, %r8
+
 	xor %rbx, %rbx # also clear carry flag
 	# r10 now contains pointer to the end of bignum
 	add_bignum_addloop:
 		movq (%rsi, %rbx, 8), %r8
 		adcq %r8, (%rdi, %rbx, 8)
 
+		incq %rbx
+		decq %r8
+		jnz add_bignum_addloop
+
+  # if sizes of bignums were different
+  # adding carry of last operation to bigger
+  # argument might be necessary
+  cmp %rcx, %rsi
+  jz add_bignum_end
+  adcq $0, (%rdi, %rbx, 8)
+	
+  add_bignum_end:
+    movq %rdi, %rax
+    ret
+
+# Adds two bignums and puts result in first of them
+# both big nums must be the same fixed size
+# void add_bignum_fast(int64_t *b1, int64_t *b2, int64_t size);
+add_bignum_fast:
+	xor %rbx, %rbx # also clear carry flag
+	# r10 now contains pointer to the end of bignum
+	add_bignum_fast_addloop:
+		movq (%rsi, %rbx, 8), %r8
+		adcq %r8, (%rdi, %rbx, 8)
+
 		incq %rbx
 		decq %rdx
 		jnz add_bignum_addloop
 	
-	movq %rdi, %rax
 	ret
-
-# null terminated string on stack
-#puts:
-#	movq 8(%rsp), %rsi
-#	movq %rsi, %rdx
-#
-#puts_str_len:
-#	movb (%rdx), %al
-#	addq $1, %rdx
-#	test %al, %al
-#	jnz puts_str_len
-#
-#	movq $SYS_WRITE, %rax
-#	movq $STDOUT, %rbx
-#	# rsi already loaded
-#	subq %rsi, %rdx
-#	syscall
-#	ret $8
diff --git a/src/main.c b/src/main.c
index d7ec3b7..829366b 100644
--- a/src/main.c
+++ b/src/main.c
@@ -3,12 +3,13 @@
 
 extern void asm_main(void);
 extern int64_t* add_bignum(int64_t *first, int64_t *second, int64_t size);
-
+extern void multiply_test(void);
 int main()
 {
-	int64_t num1[2] = {0x8000000000000000 ,0x0000000200000000};
-	int64_t num2[2] = {0x8000000000000000 ,0x0003800000000000};
-	int64_t *ret = add_bignum(num1, num2, 2);
-	printf("0x%016lx 0x%016lx\n", *(ret+1), *ret);
+// 	int64_t num1[2] = {0x8000000000000000 ,0x0000000200000000};
+// 	int64_t num2[2] = {0x8000000000000000 ,0x0003800000000000};
+// 	int64_t *ret = add_bignum(num1, num2, 2);
+// 	printf("0x%016lx 0x%016lx\n", *(ret+1), *ret);
+	multiply_test();
 	return 0;
 }
diff --git a/src/multiply.s b/src/multiply.s
index 76136c5..e59f311 100644
--- a/src/multiply.s
+++ b/src/multiply.s
@@ -1,3 +1,5 @@
+.extern malloc
+
 # define some variables
 BIGNUM_CHUNK = 7 # amount of bignum chunks
 CHUNK_SIZE = 8
@@ -9,34 +11,33 @@ SYS_EXIT = 60
 
 # buffer size
 BUFFER_SIZE = 40 * 1
-.data
-	big_value_1: # 7 lines * 64bit argument = 448bit 
-		.8byte 0x2
-		.8byte 0x2
-		.8byte 0x2
-		.8byte 0x2
-		.8byte 0x2
-		.8byte 0x2
-		.8byte 0x2
-	big_value_2: # 7 lines * 64bit argument = 448bit
-		.8byte 0x2
-		.8byte 0x2
-		.8byte 0x2
-		.8byte 0x2
-		.8byte 0x2
-		.8byte 0x2
-		.8byte 0x2
-	
 .text
-.global _start
-.global multiply
+big_value_1: # 7 lines * 64bit argument = 448bit 
+  .8byte 0x2
+  .8byte 0x2
+  .8byte 0x2
+  .8byte 0x2
+  .8byte 0x2
+  .8byte 0x2
+  .8byte 0x2
+big_value_2: # 7 lines * 64bit argument = 448bit
+  .8byte 0x2
+  .8byte 0x2
+  .8byte 0x2
+  .8byte 0x2
+  .8byte 0x2
+  .8byte 0x2
+  .8byte 0x2
+	
+.global multiply_test
+.global bignum_multiply
 
-_start:
+multiply_test:
 
 	movq $BIGNUM_CHUNK, %r8
-	movq $big_value_1, %r9
-	movq $big_value_2, %r10
-	call multiply
+	movq big_value_1(%rip), %r9
+	movq big_value_2(%rip), %r10
+	call bignum_multiply
 	pop %rax
 	movq %rbp, %rsp
 	movq $SYS_EXIT, %rax
@@ -59,7 +60,7 @@ _start:
 #      ...
 # +
 # ------------
-multiply:
+bignum_multiply:
 	push %rbp
 	movq %rsp, %rbp
 	# allocate memory on stack
@@ -96,19 +97,19 @@ multiply:
   	decq %rdi # decreament to obtain offset
   	movq (%r9,%rdi,CHUNK_SIZE), %rbx
   	cmpq %rax, %rbx
-  	jb check_next_number
+  	jb bignum_multiply_check_next_number
   	# set flag for first number
   	orq $FIRST_VALUE_SIGN_MASK, 16(%rsp)
 
-check_next_number: 
+bignum_multiply_check_next_number: 
 
   	movq (%r10, %rdi, CHUNK_SIZE), %rbx
   	cmpq %rax, %rbx
-  	jb continue_multiplication
+  	jb bignum_multiply_continue_multiplication
   	# set flag for second number
   	orq $SECOND_VALUE_SIGN_MASK, 16(%rsp)	
 
-continue_multiplication:
+bignum_multiply_continue_multiplication:
 	
 	# u64 i = 0
  	movq $0, %r12 
@@ -123,12 +124,12 @@ continue_multiplication:
   	# get result pointer
 	movq 8(%rsp), %rcx
 
-	loop_outer:
+	bignum_multiply_loop_outer:
 		# int64 second_big_val = *(bignum_second + off)
 		movq (%r10, %r12, CHUNK_SIZE), %rbx 
 		# u64 result_index = i
 		movq %r12, %r14
-		loop_inner:
+		bignum_multiply_loop_inner:
 		    
 			# int64 first_big_val = *(bignum_first + off)
 			movq (%r9, %r13, CHUNK_SIZE), %rax
@@ -148,7 +149,7 @@ continue_multiplication:
 			incq %r14 
 			# while( j < bignum_size-1 )
 			cmpq %r13, %r8
-			ja loop_inner
+			ja bignum_multiply_loop_inner
 		# last data chunk multiplication requires special treatment
 		# since it can be negative
 		# more on Dr.Tomczak sildes mnozenie.pdf str 18
@@ -163,20 +164,20 @@ continue_multiplication:
 		# check if number is negative
 		#if( mask & first_bignum_negative || mask & second_bignum_negative )
 		testq $FIRST_VALUE_SIGN_MASK, 16(%rsp)
-		jns postive_number
+		jns bignum_multiply_positive_number
 		
 		# fix number if negative 	
 		sub %rbx, 8(%rcx, %r14, CHUNK_SIZE)  
 		sbb $0,  16(%rcx, %r14, CHUNK_SIZE)
 
-		postive_number:  
+		bignum_multiply_positive_number:  
 		#j =0
 		movq $0, %r13
 		# i++
 		incq %r12 
 		# while( i < bignum_size-1 )
 		cmpq %r12, %r8
-		ja loop_outer
+		ja bignum_multiply_loop_outer
 	
 	# in this moment
 	# i = bignum_size - 1
@@ -187,7 +188,7 @@ continue_multiplication:
 	movq %r12, %r14
 	
 	# multiply it with first bignum
-	loop_last_arg:
+	bignum_multiply_loop_last_arg:
 
 		movq (%r9, %r13, CHUNK_SIZE), %rax
 		mul %rbx
@@ -199,20 +200,20 @@ continue_multiplication:
 		# check if number is negative
 		#if( mask & first_bignum_negative || mask & second_bignum_negative )
 		testq $SECOND_VALUE_SIGN_MASK, 16(%rsp)
-		jns postive_number_2
+		jns bignum_multiply_positive_number_2
 		
 		# fix number if negative 	
 		sub %rbx, 8(%rcx, %r14, CHUNK_SIZE)  
 		sbb $0,  16(%rcx, %r14, CHUNK_SIZE)
 
-		postive_number_2:  
+		bignum_multiply_positive_number_2:  
 		# calculate result index
 		incq %r14
 		# j++
 		incq %r13
 		# while( i < bignum_size-1 )
 		cmpq %r13, %r8
-		ja loop_last_arg
+		ja bignum_multiply_loop_last_arg
 
 	
 	# get last data chunk from first bignum 
@@ -237,10 +238,10 @@ continue_multiplication:
 	movq 8(%rsp), %rdx
 	# init loop counter
 	movq %rax, %rcx
-	test_loop:
+	bignum_multiply_test_loop:
 		movq (%rdx, %r14, CHUNK_SIZE), %rbx
 		incq %r14
-		loop test_loop
+		loop bignum_multiply_test_loop
 
 	# restore stack
 	movq %rbp, %rsp
@@ -267,3 +268,4 @@ zero_memory:
 
 	addq $8, %rsp	
 	ret
+
diff --git a/src/subtract.s b/src/subtract.s
index 7f701c7..8fa0982 100644
--- a/src/subtract.s
+++ b/src/subtract.s
@@ -11,63 +11,67 @@ STDOUT = 1
 STDER = 2
 # buffer size
 BUFFER_SIZE = 40 * 1
-.data
-	big_value_1: # 7 lines * 64bit argument = 448 
-		.8byte 0x1
-		.8byte 0x2
-		.8byte 0x3
-		.8byte 0x4
-		.8byte 0x5
-		.8byte 0x6
-		.8byte 0x7
-	big_value_2: # 7 lines * 64bit argument = 448
-		.8byte 0x0
-		.8byte 0x2
-		.8byte 0x3
-		.8byte 0x4
-		.8byte 0x5
-		.8byte 0x6
-		.8byte 0x8
-	
+
 .text
-.global subtract_main
+.global subtract_test
 .global substract
 
-subtract_main:
+big_value_1: # 7 lines * 64bit argument = 448 
+  .8byte 0x1
+  .8byte 0x2
+  .8byte 0x3
+  .8byte 0x4
+  .8byte 0x5
+  .8byte 0x6
+  .8byte 0x7
+big_value_2: # 7 lines * 64bit argument = 448
+  .8byte 0x0
+  .8byte 0x2
+  .8byte 0x3
+  .8byte 0x4
+  .8byte 0x5
+  .8byte 0x6
+  .8byte 0x8
+
+subtract_test:
 	
 	leaq BIGNUM_CHUNK(%rip), %rax
 	leaq big_value_1(%rip), %rbx
 	leaq big_value_2(%rip), %rcx
-	call substract
+	call bignum_subtract
 	pop %rax
 	movq %rbp, %rsp
 	movq $SYS_EXIT, %rax
 	xor %rdi, %rdi
 	syscall
 
-# from first bignum argument substract second bignum argument
+# from first bignum argument subtract second bignum argument
 # rax contains sizeof currently handle bignums
 # rbx contains pointer to first bignum argument
 # rcx constains pointer to second bignum argument
-substract:
+bignum_subtract:
 	# clear carry flag
 	clc
 	# set index counter to 0
 	movq $0, %rdx
 	# make divison with borrow
-	L1:
-	# arg1 = *(big_value_1 +off)
-	movq (%rbx,%rdx,WORD_SIZE), %r8
-	# arg2 = *(big_value_2 + off)
-	movq (%rcx,%rdx,WORD_SIZE), %r9
-	# arg2 = arg2 - arg1
-	sbbq %r8, %r9
-	# *big_value_2 = arg2 
-	movq %r9, (%rcx,%rdx,WORD_SIZE)
-	# increment index
-	incq %rdx
-	# decrement  
-	decq %rax
-	jnz L1
+	bignum_subtract_L1:
+    # arg1 = *(big_value_1 +off)
+    movq (%rbx,%rdx,WORD_SIZE), %r8
+    # arg2 = *(big_value_2 + off)
+    movq (%rcx,%rdx,WORD_SIZE), %r9
+    # arg2 = arg2 - arg1
+    sbbq %r8, %r9
+    # *big_value_2 = arg2 
+    movq %r9, (%rcx,%rdx,WORD_SIZE)
+    # increment index
+    incq %rdx
+    # decrement  
+    decq %rax
+    jnz bignum_subtract_L1
 
 	ret
+# from first bignum argument substract second bignum argument
+# rax contains sizeof currently handle bignums
+# rbx contains pointer to first bignum argument
+# rcx constains pointer to second bignum argument
diff --git a/src/test_utils.c b/tests/test_utils.c
similarity index 100%
rename from src/test_utils.c
rename to tests/test_utils.c
